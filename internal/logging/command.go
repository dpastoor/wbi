package logging

import (
	"errors"
	"fmt"
	"log"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/sol-eng/wbi/internal/config"
)

var (
	cmdlog *logrus.Logger
)

type MyFormatter struct {
}

func (f *MyFormatter) Format(entry *logrus.Entry) ([]byte, error) {
	return []byte(entry.Message), nil
}

func init() {
	// Setup the command output file
	timestamp := time.Now().Format("20060102T150405")
	logFile := "wbi-command-" + timestamp + ".sh"
	f, err := os.OpenFile(logFile, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0700)
	if err != nil {
		log.Fatalf("error opening file: %v", err)
	}

	cmdlog = logrus.New()

	cmdlog.SetOutput(f)
	cmdlog.SetFormatter(new(MyFormatter))

	// Determine OS and install pre-requisites
	osType, _ := DetectOS()
	hostname, _ := os.Hostname()

	commentMessage := fmt.Sprintf("# This file was generated by the Workbench Installer (WBI) command line tool.\n# Host: %s, OS: %s, Timestamp: %s\n# This script may contain out of date or non-functional commands if sufficient time has elapsed or if run on a different operating system/server setup.", hostname, osType.ToString(), timestamp)

	cmdlog.Info("#!/bin/bash\n")
	cmdlog.Info(commentMessage + "\n\n")
}

// Info ...
func Info(format string, v ...interface{}) {
	cmdlog.Infof(format, v...)
}

// Warn ...
func Warn(format string, v ...interface{}) {
	cmdlog.Warnf(format, v...)
}

// Error ...
func Error(format string, v ...interface{}) {
	cmdlog.Errorf(format, v...)
}

// Detect which operating system WBI is running on
// this is duplicated in operatingsystem/detect.go but cannot import that package here
func DetectOS() (config.OperatingSystem, error) {
	osType := runtime.GOOS
	if osType == "linux" {
		// Check RHEL
		if _, err := os.Stat("/etc/redhat-release"); err == nil {
			releaseVersionRHEL, err := os.ReadFile("/etc/redhat-release")
			if err != nil {
				return config.Unknown, err
			}
			if strings.Contains(string(releaseVersionRHEL), "release 7") {
				return config.Redhat7, nil
			} else if strings.Contains(string(releaseVersionRHEL), "release 8") {
				return config.Redhat8, nil
			} else if strings.Contains(string(releaseVersionRHEL), "release 9") {
				return config.Redhat9, nil
			} else {
				return config.Unknown, errors.New("unsupported operating system")
			}
		} else if _, err := os.Stat("/etc/issue"); err == nil {
			releaseVersionUbuntu, err := os.ReadFile("/etc/issue")
			if err != nil {
				return config.Unknown, err
			}
			if strings.Contains(string(releaseVersionUbuntu), "Ubuntu 22") {
				return config.Ubuntu22, nil
			} else if strings.Contains(string(releaseVersionUbuntu), "Ubuntu 20") {
				return config.Ubuntu20, nil
			} else if strings.Contains(string(releaseVersionUbuntu), "Ubuntu 18") {
				return config.Ubuntu18, nil
			} else {
				return config.Unknown, errors.New("unsupported operating system")
			}
		} else {
			return config.Unknown, errors.New("unsupported operating system")
		}
	} else {
		return config.Unknown, errors.New("unsupported operating system")
	}
}
